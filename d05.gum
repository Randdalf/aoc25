import aoc
import math
import sort for sort

class id_range:
    init(start, end):
        self.start = start
        self.end = end

    fn overlaps(other):
        return not ((other.end < self.start - 1) or (other.start > self.end + 1))

    fn merge(other):
        return id_range(
            math.min(self.start, other.start),
            math.max(self.end, other.end)
        )

    fn contains(id):
        return id >= self.start and id <= self.end
    
    op <(lhs, rhs):
        return lhs.start < rhs.start

    op ==(lhs, rhs):
        return lhs.start == rhs.start

fn merge_ranges(ranges):
    sort(ranges)
    merged = []
    current = nil
    for range in ranges:
        if not current:
            current = range
        elif current.overlaps(range):
            current = current.merge(range)
        else:
            merged.add(current)
            current = range
    if current:
        merged.add(current)
    return merged

export fn part1(input):
    parts = input.split("\r\n\r\n")

    # Parse the ranges.
    ranges = []
    for line in parts[0].split("\r\n"):
        ends = line.split("-")
        ranges.add(id_range(int(ends[0]), int(ends[1])))

    # Merge overlapping ranges.
    ranges = merge_ranges(ranges)

    # Find the fresh ids
    num_fresh = 0
    for line in parts[1].split("\r\n"):
        id = int(line)
        for range in ranges:
            if range.contains(id):
                num_fresh += 1
                break
        
    return num_fresh

export fn part2(input):
    pass

if is_main():
    aoc.solve(5, part1, part2)
