import aoc
import math
import sort for sort

class Range:
    init(start, end):
        self.start = start
        self.end = end

    fn overlaps(other):
        return not ((other.end < self.start - 1) or (other.start > self.end + 1))

    fn merge(other):
        return Range(
            math.min(self.start, other.start),
            math.max(self.end, other.end)
        )

    fn contains(id):
        return id >= self.start and id <= self.end

    fn num():
        return self.end - self.start + 1
    
    op <(lhs, rhs):
        return lhs.start < rhs.start

    op ==(lhs, rhs):
        return lhs.start == rhs.start

fn merge_ranges(ranges):
    sort(ranges)
    merged = []
    current = nil
    for range in ranges:
        if not current:
            current = range
        elif current.overlaps(range):
            current = current.merge(range)
        else:
            merged.add(current)
            current = range
    if current:
        merged.add(current)
    return merged

class Database:
    init(input):
        parts = input.split("\r\n\r\n")

        # Parse the ranges and merge them.
        ranges = []
        for line in parts[0].split("\r\n"):
            ends = line.split("-")
            ranges.add(Range(int(ends[0]), int(ends[1])))
        self.ranges = merge_ranges(ranges)

        # Parse the ids.
        ids = []
        for line in parts[1].split("\r\n"):
            ids.add(int(line))
        self.ids = ids

export fn part1(input):
    db = Database(input)
    num_fresh = 0
    for id in db.ids:
        for range in db.ranges:
            if range.contains(id):
                num_fresh += 1
                break
    return num_fresh

export fn part2(input):
    db = Database(input)
    num_fresh = 0
    for range in db.ranges:
        num_fresh += range.num()
    return num_fresh

if is_main():
    aoc.solve(5, part1, part2)
