import aoc
import sort for sort

class JunctionBox:
    init(x, y, z):
        self.x = x
        self.y = y
        self.z = z
        self.connections = []

    fn dist(other):
        dx = self.x - other.x
        dy = self.y - other.y
        dz = self.z - other.z
        return dx*dx + dy*dy + dz*dz

    fn str():
        return "{self.x},{self.y},{self.z}"

class Dist:
    init(i, j, value):
        self.i = i
        self.j = j
        self.value = value

    fn connect(jbs):
        jbs[self.i].connections.add(self.j)
        jbs[self.j].connections.add(self.i)
    
    op <(a, b):
        return a.value < b.value

class Playground:
    init(input):
        # Parse all the junction boxes.
        jbs = []
        for line in input.split("\r\n"):
            comps = line.split(",")
            x = int(comps[0])
            y = int(comps[1])
            z = int(comps[2])
            jbs.add(JunctionBox(x, y, z))

        # Calculate the distance between each unique pair of junction boxes and then
        # sort them by distance.
        dists = []
        for i in 0...jbs.num():
            for j in (i+1)...jbs.num():
                dists.add(Dist(i, j, jbs[i].dist(jbs[j])))
        sort(dists)

        self.jbs = jbs
        self.dists = dists

export n = 1000

fn get_circuit_size(jbs, root, visited):
    size = 0
    visited.add(root, nil)
    pending = [root]
    while pending.num() > 0:
        size += 1
        for j in jbs[pending.pop()].connections:
            if j in visited:
                continue
            visited.add(j, nil)
            pending.add(j)
    return size

export fn part1(input):
    pg = Playground(input)
    jbs = pg.jbs
    dists = pg.dists

    # Add connections between the closest n pairs of junction boxes.
    for step in 0...n:
        dists[step].connect(jbs)

    # Determine the size of the circuits formed by the connections.
    sizes = []
    visited = {}
    for i in 0...jbs.num():
        sizes.add(get_circuit_size(jbs, i, visited))

    # Multiple the three largest circuit sizes to get the result.
    sort(sizes)
    return sizes[-1] * sizes[-2] * sizes[-3]

export fn part2(input):
    pg = Playground(input)
    jbs = pg.jbs
    dists = pg.dists

    # Add connections until the graph is complete.
    for dist in dists:
        dist.connect(jbs)
        if get_circuit_size(jbs, 0, {}) == jbs.num():
            return jbs[dist.i].x * jbs[dist.j].x

if is_main():
    aoc.solve(8, part1, part2)
